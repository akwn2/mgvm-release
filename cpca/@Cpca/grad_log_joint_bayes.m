function ndlogP = grad_log_joint_bayes(self, vararray)
% grad_log_joint_bayes
% Calculates the gradient of the average log-joint distribution for the
% variational bayes model.

    self.unpack_from_array(vararray,'variables', 'Fq');

    % GRADIENTS W.R.T. POINT ESTIMATES IN THE (HYPER)-PRIORS
    %--------------------------------------------------------
    % Derivatives of the priors for the ARD components

    % Prior for alph2 - gradients for the point estimates
    self.p_a_alph2.dx = log(self.p_b_alph2.xv) ...
                      - polygamma(0, self.p_a_alph2.xv) ...
                      + log(self.m_alph2.xv);

    self.p_b_alph2.dx = self.p_a_alph2.xv ./ self.p_b_alph2.xv ...
                      - log(self.m_alph2.xv);

    % Prior for beta2 - gradients for the point estimates
    self.p_a_beta2.dx = log(self.p_b_beta2.xv)...
                      - polygamma(0, self.p_a_beta2.xv) ...
                      + log(self.m_beta2.xv);

    self.p_b_beta2.dx = self.p_a_beta2.xv ./ self.p_b_beta2.xv ...
                     - log(self.m_beta2.xv);

    % Prior for prc2 - gradients for the point estimates
    self.p_a_prc2.dx = log(self.p_b_prc2.xv) ...
                     - polygamma(0, self.p_a_prc2.xv) ...
                     + log(self.m_prc2.xv);

    self.p_b_prc2.dx = self.p_a_prc2.xv ./ self.p_b_prc2.xv ...
                     - log(self.m_prc2.xv);

    % Prior for phi - gradients for the point estimates
    b_ratio = ive(1, self.p_kappa.xv) ./ ive(0, self.p_kappa.xv);

    self.p_kappa.dx = - self.N .* b_ratio + sum(self.m_cos_phi.xv, 2);


    % GRADIENTS W.R.T. MODEL LIKELIHOOD
    %------------------------------------------

    % No gradients to be taken w.r.t the likelihood (likelihood
    % only affets gradients through the Variational parameters)


    % GRADIENTS W.R.T. VARIATIONAL PARAMETERS
    %-----------------------------------------------------------

    % Trigonometric terms
    ccT = self.m_cos_phi.xv * self.m_cos_phi.xv' ...
        + diag(- diag(self.m_cos_phi.xv * self.m_cos_phi.xv') ...
               + sum(self.m_cos2_phi.xv, 2));

    scT = self.m_sin_phi.xv * self.m_cos_phi.xv' ...
        + diag(- diag(self.m_sin_phi.xv * self.m_cos_phi.xv') ...
               + sum(self.m_sincos_phi.xv, 2));

    ssT = self.m_sin_phi.xv * self.m_sin_phi.xv' ...
        + diag(- diag(self.m_sin_phi.xv * self.m_sin_phi.xv') ...
               + sum(self.m_sin2_phi.xv, 2));
           
    % Model predictions
    modelPred = self.m_A.xv * self.m_cos_phi.xv ...
              + self.m_B.xv * self.m_sin_phi.xv;

    % Norm within the Likelihood term
    normTerm = self.trYYT - 2 * trace(modelPred * self.Y') ...
             + trace( self.m_AA.xv * ccT + 2 * self.m_AB.xv * scT ...
                    + self.m_BB.xv * ssT );

    % Gradients of the variational parameters of q(alph2)
    dlogp_m_alph2 = (self.p_a_alph2.xv - 1) ./ self.m_alph2.xv ...
                  - self.p_b_alph2.xv ...
                  + 0.5 .* self.M ./ self.m_alph2.xv ...
                  - 0.5 .* diag(self.m_AA.xv);

    self.q_alph2_a.dx = dlogp_m_alph2 .* self.m_alph2.dx{1}; % d/da <alph2>
    self.q_alph2_b.dx = dlogp_m_alph2 .* self.m_alph2.dx{2}; % d/db <alph2>

    % Gradients of the variational parameters of q(beta2)
    dlogp_m_beta2 = (self.p_a_beta2.xv - 1) ./ self.m_beta2.xv ...
                  - self.p_b_beta2.xv ...
                  + 0.5 .* self.M ./ self.m_beta2.xv ...
                  - 0.5 .* diag(self.m_BB.xv);

    self.q_beta2_a.dx = dlogp_m_beta2 .* self.m_beta2.dx{1}; % d/da<beta2>
    self.q_beta2_b.dx = dlogp_m_beta2 .* self.m_beta2.dx{2}; % d/db<beta2>

    % Gradients of the variational parameters of q(prc2)
    dlogp_m_prc2 =  (self.p_a_prc2.xv - 1) ./ self.m_prc2.xv ...
                  - self.p_b_prc2.xv ...
                  + 0.5 * (self.N * self.M ./ self.m_prc2.xv - normTerm);

    self.q_prc2_a.dx = dlogp_m_prc2 .* self.m_prc2.dx{1}; % d/da<prc2>
    self.q_prc2_b.dx = dlogp_m_prc2 .* self.m_prc2.dx{2}; % d/db<prc2>


    % Gradients of the variational parameters of q(A,B,c)
    % Means
    dlogp_m_A = - repmat(self.m_alph2.xv', [self.M, 1]) .* self.m_A.xv ...
                - self.m_prc2.xv * (- self.Y * self.m_cos_phi.xv' ...
                                    + self.m_A.xv * ccT ...
                                    + self.m_B.xv * scT);

    dlogp_m_B = - repmat(self.m_beta2.xv', [self.M, 1]) .* self.m_B.xv ...
                - self.m_prc2.xv * (- self.Y * self.m_sin_phi.xv' ...
                                    + self.m_B.xv * ssT ...
                                    + self.m_A.xv * scT');

    self.q_A_mu.dx = dlogp_m_A .* self.m_A.dx;
    self.q_B_mu.dx = dlogp_m_B .* self.m_B.dx;

    % Blocks of the covariance
    dlogp_AA_cov = - 0.5 * (diag(self.m_alph2.xv) + self.m_prc2.xv * ccT);
    dlogp_BB_cov = - 0.5 * (diag(self.m_beta2.xv) + self.m_prc2.xv * ssT);
    dlogp_AB_cov = - 0.5 * self.m_prc2.xv * scT;
    
    AA_cov = reshape(self.q_AA_cov.xv(:), [self.D, self.D, self.M]);
    dAA_cov = zeros(size(AA_cov));

    AB_cov = reshape(self.q_AB_cov.xv(:), [self.D, self.D, self.M]);
    dAB_cov = zeros(size(AB_cov));

    BB_cov = reshape(self.q_BB_cov.xv(:), [self.D, self.D, self.M]);
    dBB_cov = zeros(size(BB_cov));

    for mm = 1:self.M
        dAA_cov(:,:,mm) = dAA_cov(:,:,mm) ...
                        + 2 * AA_cov(:,:,mm) * dlogp_AA_cov...
                        + 2 * AB_cov(:,:,mm) * dlogp_AB_cov;

        dAB_cov(:,:,mm) = dAB_cov(:,:,mm) ...
                        + 2 * AA_cov(:,:,mm) * dlogp_AB_cov'...
                        + 2 * AB_cov(:,:,mm) * dlogp_BB_cov;

        dBB_cov(:,:,mm) = dBB_cov(:,:,mm) ...
                        + 2 * BB_cov(:,:,mm) * dlogp_BB_cov;
    end
    self.q_AA_cov.dx = dAA_cov(:);
    self.q_AB_cov.dx = dAB_cov(:);
    self.q_BB_cov.dx = dBB_cov(:);

    % Gradients of the variational parameters of q(phi)
    dlogp_mc = zeros(self.D, self.N);
    dlogp_ms = zeros(self.D, self.N);
    dlogp_mc2 = zeros(self.D, self.N);
    dlogp_ms2 = zeros(self.D, self.N);
    dlogp_msc = zeros(self.D, self.N);

    for dd = 1:self.D
        dlogp_mc(dd, :) = self.p_kappa.xv(dd) - self.m_prc2.xv * ...
           (-self.m_A.xv(:, dd)' * self.Y ...
           + self.m_AA.xv(dd, 1:self.D ~= dd) * ...
                    self.m_cos_phi.xv(1:self.D ~= dd, :) ...
           + self.m_AB.xv(dd, 1:self.D ~= dd) * ...
                    self.m_sin_phi.xv(1:self.D ~= dd, :) );

        dlogp_ms(dd, :) = - self.m_prc2.xv * ...
           (-self.m_B.xv(:, dd)' * self.Y ...
           + self.m_BB.xv(dd, 1:self.D ~= dd) * ...
                    self.m_sin_phi.xv(1:self.D ~= dd, :) ...
           + self.m_AB.xv(1:self.D ~= dd, dd)' * ...
                    self.m_cos_phi.xv(1:self.D ~= dd, :) );

        dlogp_mc2(dd, :) = - 0.5 * self.m_prc2.xv * self.m_AA.xv(dd, dd);

        dlogp_ms2(dd, :) = - 0.5 * self.m_prc2.xv * self.m_BB.xv(dd, dd);

        dlogp_msc(dd, :) = - self.m_prc2.xv * self.m_AB.xv(dd, dd);
    end
    % Trigonometric functions derivatives

    % Assemble the derivatives by the chain rule
    self.q_phi_k1.dx = dlogp_mc .* self.g_cos_phi_k1 ...
             + dlogp_ms .* self.g_sin_phi_k1 ...
             + dlogp_mc2 .* self.g_cos2_phi_k1 ...
             + dlogp_ms2 .* self.g_sin2_phi_k1 ...
             + dlogp_msc .* self.g_sincos_phi_k1;
         
    self.q_phi_m1.dx = dlogp_mc .* self.g_cos_phi_m1 ...
             + dlogp_ms .* self.g_sin_phi_m1 ...
             + dlogp_mc2 .* self.g_cos2_phi_m1 ...
             + dlogp_ms2 .* self.g_sin2_phi_m1 ...
             + dlogp_msc .* self.g_sincos_phi_m1;

    if strcmp(self.q_phi_type, 'GvM')

        self.q_phi_k2.dx = dlogp_mc .* self.g_cos_phi_k2 ...
                 + dlogp_ms .* self.g_sin_phi_k2 ...
                 + dlogp_mc2 .* self.g_cos2_phi_k2 ...
                 + dlogp_ms2 .* self.g_sin2_phi_k2 ...
                 + dlogp_msc .* self.g_sincos_phi_k2;

        self.q_phi_m2.dx = dlogp_mc .* self.g_cos_phi_m2 ...
                 + dlogp_ms .* self.g_sin_phi_m2 ...
                 + dlogp_mc2 .* self.g_cos2_phi_m2 ...
                 + dlogp_ms2 .* self.g_sin2_phi_m2 ...
                 + dlogp_msc .* self.g_sincos_phi_m2;
    end
    
    ndlogP = - self.pack_as_array('gradients', 'Fq');

    % Check for numerical errors
    assert_real(ndlogP);
end