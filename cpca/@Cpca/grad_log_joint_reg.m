function ndlogP = grad_log_joint_reg(self, vararray)
% grad_log_joint_reg
% Calculates the gradient of the average log-joint distribution for the
% regression model.

    self.unpack_from_array(vararray, 'variables', 'Fq');

    % GRADIENTS W.R.T. MODEL LIKELIHOOD
    % ------------------------------------------

    %Likelihood
    b_ratio = ive(1, self.p_kappa.xv) ./ ive(0, self.p_kappa.xv);

    self.p_kappa.dx = - self.N .* b_ratio ...
                    + sum(self.m_cos_phi.xv .* self.cos_y ...
                        + self.m_sin_phi.xv .* self.sin_y, 2);

    % GRADIENTS W.R.T. VARIATIONAL PARAMETERS
    % -----------------------------------------------------------
    
    % Gradients of the variational parameters of q(phi)
    dprior_mc = zeros(self.D, self.N);
    dprior_ms = zeros(self.D, self.N);
    dprior_mc2 = zeros(self.D, self.N);
    dprior_ms2 = zeros(self.D, self.N);
    dprior_msc = zeros(self.D, self.N);

    for dd = 1:self.D
        dprior_mc(dd, :) = self.p_kappa.xv(dd) * self.cos_y(dd, :) ...
           - (self.p_Wcc.xv(dd, 1:self.D ~= dd) * ...
                    self.m_cos_phi.xv(1:self.D ~= dd, :) ...
            + self.p_Wcs.xv(dd, 1:self.D ~= dd) * ...
                    self.m_sin_phi.xv(1:self.D ~= dd, :) );

        dprior_ms(dd, :) = self.p_kappa.xv(dd) * self.sin_y(dd, :) ...
           - (self.p_Wss.xv(dd, 1:self.D ~= dd) * ...
                    self.m_sin_phi.xv(1:self.D ~= dd, :) ...
            + self.p_Wcs.xv(1:self.D ~= dd, dd)' * ...
                    self.m_cos_phi.xv(1:self.D ~= dd, :) );

        dprior_mc2(dd, :) = - 0.5 * self.p_Wcc.xv(dd, dd);

        dprior_ms2(dd, :) = - 0.5 * self.p_Wss.xv(dd, dd);

        dprior_msc(dd, :) = - self.p_Wcs.xv(dd, dd);
    end
    % Trigonometric functions derivatives

    % Assemble the derivatives by the chain rule
    self.q_phi_k1.dx = ...
               dprior_mc .* self.g_cos_phi_k1 ...
             + dprior_ms .* self.g_sin_phi_k1 ...
             + dprior_mc2 .* self.g_cos2_phi_k1 ...
             + dprior_ms2 .* self.g_sin2_phi_k1 ...
             + dprior_msc .* self.g_sincos_phi_k1;

    self.q_phi_m1.dx = ...
               dprior_mc .* self.g_cos_phi_m1 ...
             + dprior_ms .* self.g_sin_phi_m1 ...
             + dprior_mc2 .* self.g_cos2_phi_m1 ...
             + dprior_ms2 .* self.g_sin2_phi_m1 ...
             + dprior_msc .* self.g_sincos_phi_m1;

    if strcmp(self.q_phi_type, 'GvM')
        self.q_phi_k2.dx = ...
                   dprior_mc .* self.g_cos_phi_k2 ...
                 + dprior_ms .* self.g_sin_phi_k2 ...
                 + dprior_mc2 .* self.g_cos2_phi_k2 ...
                 + dprior_ms2 .* self.g_sin2_phi_k2 ...
                 + dprior_msc .* self.g_sincos_phi_k2;

        self.q_phi_m2.dx = ...
                   dprior_mc .* self.g_cos_phi_m2 ...
                 + dprior_ms .* self.g_sin_phi_m2 ...
                 + dprior_mc2 .* self.g_cos2_phi_m2 ...
                 + dprior_ms2 .* self.g_sin2_phi_m2 ...
                 + dprior_msc .* self.g_sincos_phi_m2;
    end

    ndlogP = - self.pack_as_array('gradients', 'Fq');


    if any(isinf(ndlogP)) || any(isnan(ndlogP)) || any(~isreal(ndlogP))
        fprintf('Something went wrong in grad_LogP\n');
        keyboard;
    end
end